{% load static %}
<script src="{% static "vendor/emojione.min.js" %}"></script>
<link rel="stylesheet" href="{% static "vendor/emojione.min.css" %}"/>

<script src="{% static "vendor/push.js" %}"> </script>

<link href="https://cdn.quilljs.com/1.2.3/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.2.3/quill.js"></script>

<style>
#discussion-your-comment-tips {
  padding: 2px;
  font-size: 85%;
  color: #555;
}
  #discussion-your-comment-tips label {
    color: inherit;
    font-weight: normal;
    cursor: pointer;
  }

#discussion .comment-thread {
  margin-bottom: 1.5em;
}

#discussion .comment {
  margin-bottom: 15px;
}
#discussion .comment .comment-avatar, #discussion .event .event-avatar {
  border-radius: 10px;
  border: 1px solid #CCC;
}
#discussion .comment .comment-meta {
  margin: -15px -15px 15px -15px;
  padding: 10px 15px;
  border-bottom: 1px solid #EEE;
}
#discussion .comment .comment-commands {
  text-align: right;
}
  #discussion .comment .comment-commands > * {
    margin-left: 15px;
    color: #999;
  }
    #discussion .comment .comment-commands > *:hover {
      color: #5A5;
    }
  #discussion .comment .comment-author {
  }
    #discussion .comment.author-is-self .comment-author {
      font-weight: bold;
    }
  #discussion .comment .comment-author-role {
  }
#discussion .comment .ifeditpriv { display: none; }
#discussion .comment.has-edit-priv .ifeditpriv { display: inline; }
#discussion .comment .ifdeletepriv { display: none; }
#discussion .comment.has-delete-priv .ifdeletepriv { display: inline; }
#discussion .comment.author-is-self .ifnotauthor { display: none; }
#discussion .comment .replies {
  margin: 15px -15px -15px -15px;
  padding: 0 15px;
  border-top: 1px solid #EEE;
  font-size: 95%;
}
  #discussion .comment .replies .reply {
    margin: 15px 0;
  }
#discussion .comment .comment-text {
  overflow-wrap: break-word;
}
  #discussion .comment .comment-text p:last-child {
    margin-bottom: 0;
  }
#discussion .event {
  margin-bottom: 20px; /* comments look like they have a margin-bottom of 15px but the panel within it has a margin-bottom of 20px */
}
  #discussion .event-body {
    margin-left: .5em;
  }
  #discussion .event .event-text {
  }
  #discussion .event .event-info {
    font-size: 85%;
    color: #555;
    margin: 4px 0;
  }

#emoji-selector .emoji {
  display: inline-block;
  margin-right: 1px;
  cursor: pointer;
  padding: 3px;
}
  .emojione { margin: 0; }
  #emoji-selector .emoji.active {
    padding: 2px;
    border: 1px solid #DDE;
    background-color: #EEF;
  }
</style>

<div id="discussion" style="display: none;">
    <div class="comment-thread">
      
    </div>
    <div class="comment-input active-discussion-only" style="display: none">
      <form onsubmit="submit_comment(); return false;">
        <label id="discussion-your-comment-label" for="discussion-your-comment">
          ...
        </label>
        <div style="position: relative;">
          <div id="discussion-your-comment"></div>
          <div id="discussion-your-comment-saved" style="display: none; position: absolute; bottom: 8px; right: 8px; padding: .25em; background-color: rgba(255,255,255,.9); border: 1px solid #DDD; border-radius: .25em;"></div>
        </div>
        <div id="discussion-your-comment-tips">
         <label for="discussion-attach-file">Attach a File</label>
         <div style="display: none">
            <input name="value" type="file" id="discussion-attach-file" multiple onchange="attach_files(this.files)" />
         </div>
        </div>
        <div style="margin-top: 1em; text-align: right">
          {# <button type="submit" class="btn btn-default">Propose an Answer</button> #}
          {% if discussion_close_and_comment_strings %}
          <button class="btn btn-default" onclick="submit_comment(close_and_comment_clicked);">
            {% for css_class, text in discussion_close_and_comment_strings %}
              <span class="{{css_class}}" style="display: none">{{text}}</span>
            {% endfor %}
          </button>
          {% endif %}
          <button type="submit" class="btn btn-primary">Comment</button>
        </div>
      </form>
    </div>

    <p id="discussion-you-are-alone" style="display: none" class="text-danger">
      You are the only person in this conversation so far. <a href="#" onclick="return invite_user_to_discussion()" class="btn btn-link btn-default">Invite a colleague</a> to join you.
    </p>

    {% if show_discussion_members_count %}
    <p class="small active-discussion-only" style="display: none">
      Who can see this conversation? <span class="fillin-project_name"></span> members<span class="fillin-guests"></span>.
      <a id="invite-guest" href="#" onclick="return invite_user_to_discussion()">Invite Colleague</a>
    </p>
    {% endif %}
</div>

<div id="comment-template" style="display: none">
  <div class="comment row">
    <div class="col-xs-2 col-lg-1" style="padding-right: 0"> {# kill the right padding so we get rid of half of the gutter so the avatar isn't so far away, and do it here and not on the next column because tk's header lines up better #}
      <img class="comment-avatar img-responsive" style="display: none">
    </div>
    <div class="col-xs-10 col-lg-11">
    <div class="panel panel-default">
    <div class="panel-body">
      <div class="comment-meta">
        <div class="row">
          <div class="col-sm-10">
            <span class="comment-author">...</span>
            <span class="comment-author-role">...</span>
            commented
            <span class="comment-date"></span>
          </div>
          <div class="col-sm-2 comment-commands">
            <a title="Edit your comment" class="ifeditpriv" href="#" onclick="return begin_comment_edit(this);">
              <i class="glyphicon glyphicon-pencil"></i>
            </a>
            <a title="React to this comment with an emoji" class="ifnotauthor react-with-emoji" href="#" onclick="return begin_emoji_reaction(event, this);">
              <i class="glyphicon glyphicon-plus"></i>
              <i class="glyphicon glyphicon-heart"></i>
            </a>
            <a title="Delete this comment" class="ifdeletepriv" href="#" onclick="return do_delete_comment(this);">
              <i class="glyphicon glyphicon-trash"></i>
            </a>
          </div>
        </div> <!-- /row -->
      </div> <!-- /comment-meta -->
      <div class="comment-text"> </div>

      <form class="comment-edit clearfix" style="display: none" onsubmit="do_comment_save(this); return false;">
        <textarea class="form-control" style="width: 100%;"> </textarea>
        <div style="margin: 1em 0; float: right">
          <button type="submit" class="btn btn-cancel" onclick="return close_comment_edit(this);">Cancel</button>
          <button type="submit" class="btn btn-primary">Save</button>
        </div>
      </form>

      {% comment %}
      <div class="proposed-answer">
        <div class="radio">
          <label>
            <input type="radio" disabled> No
          </label>
        </div>
        <div class="radio">
          <label>
            <input type="radio" checked disabled> Yes
          </label>
        </div>
      </div>
      {% endcomment %}

      <div class="replies">
      </div>
    </div> <!-- /panel-body -->
  </div> <!-- /panel -->
 </div> <!-- /col -->
 </div> <!-- /row -->
</div> <!-- /template -->

<div id="reply-template" style="display: none">
  <div class="reply">
    <span class="comment-author">...</span>
    <span class="comment-author-role"></span>
    reacted
    <span class="comment-emojis"></span>
    <span class="comment-date"></span>
  </div>
</div>

<div id="event-template" style="display: none">
  <div class="event">
    <div class="row">
      <div class="col-xs-2 col-lg-1" style="padding-right: 0"> {# kill the right padding so we get rid of half of the gutter so the avatar isn't so far away, and do it here and not on the next column because tk's header lines up better #}
        <img class="event-avatar img-responsive" style="display: none">
      </div>
      <div class="col-xs-10 col-lg-11">
        <div class="event-body">
          <div class="event-text"> </div>
          <div class="event-info">
            <div>
              <span class="event-date"></span>
              <span class="event-who"></span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="emoji-selector" style="display: none; border-top: 10px solid rgba(255,255,255, .5); border-left: 10px solid rgba(255,255,255, .5);">
  <div class="panel panel-default" style="margin: 0">
    <div class="panel-heading" style="padding: 5px 15px;">
      <button type="button" class="close" aria-label="Close" onclick="save_emoji_reaction()">
        <span aria-hidden="true">&times;</span>
      </button>
      <b>React with an emoji</b>
    </div>
    <div class="panel-body">
      <div>
      </div>  
      <div>
        <div class="emoji" title="React with a heart!">heart</div>
        <div class="emoji" title="React with a thumbs-up!">thumbsup</div>
        <div class="emoji" title="React with a thumbs-down!">thumbsdown</div>
        <div class="emoji" title="React with a smiley face!">smile</div>
        <div class="emoji" title="React with a frowning face!">slight_frown</div>
      </div>
    </div>
    </div>
  </div>

<script>

function init_discussion_html() {
  // Clicks outside of the emoji-selector trigger closing & saving the dialog.
  $(document).click(save_emoji_reaction);
  $('body').append($('#emoji-selector')); // move to body to make positioning easier in case this whole template is inside a relatively positioned element like a col
  $('#emoji-selector').click(function(event) { event.stopPropagation(); });
  $('#emoji-selector .emoji').each(function() {
    // Initialize - replace text in markup with images.
    var shortname = $(this).text();
    $(this)
      .html(emojione.toImage(":" + shortname + ":"))
      .click(function() { $(this).toggleClass('active'); })
      .attr('data-emoji-name', shortname);
  });
};

var discussion_info = { max_event_time: 0 };
var discussion_has_any_comment = false;
var discussion_has_any_comment_from_someone_else = false;
var discussion_comment_count = 0;

function display_discussion(discussion, is_page_load) {
  // first time initialization
  if (window.init_discussion_html)
    init_discussion_html();
  else
    delete window.init_discussion_html;

  // remember what discussion is displayed
  discussion_info = discussion.discussion;

  // show the discussion
  $('#discussion').show();
  $('#discussion .active-discussion-only').show();
  $('#discussion-your-comment-label').text("Add the first comment:")
  $('#discussion #invite-guest').toggle(discussion_info.can_invite);

  // INITIALIZE THE COMMENT EDITOR

  // initialize the editor
  quill = new Quill('#discussion-your-comment', {
    theme: 'snow',
    formats: ['bold', 'italic', 'code', 'link', 'blockquote', 'header', 'list', 'code-block', 'image'],
    modules: {
      toolbar: [['bold', 'italic', 'code'], [{ header: 1 }, { header: 2 }, { list: 'ordered' }, { list: 'bullet' }, 'blockquote', 'code-block'], ['link', 'image']]
    }
  });
  $('#discussion-your-comment').keydown(function(e) {
    if ((e.ctrlKey || e.metaKey) && (e.keyCode == 13 || e.keyCode == 10))
      $(this).parents('form').submit();
  });

  if (!is_page_load || discussion.events.length == 0) quill.focus();

  // show an existing draft and poll for updating the draft
  if (discussion.draft) {
    draft_state = discussion.draft;
    quill.clipboard.dangerouslyPasteHTML(0, discussion.draft.text_rendered);
  }

  // start polling for changes to save as draft
  start_update_draft_poller();

  // BUTTON LABEL TOGGLES

  // toggle a class depending on whether the user's comment textarea has
  // anything in it, which is used if we have a "Close & Comment" / "Re-open & Comment"
  // button
  quill.isEmpty = function() {
    var content = this.getContents();
    var ret = true;
    content.ops.forEach(function(op) {
        if (typeof op.insert != "string" || /\S/.test(op.insert))
          ret = false;
    })
    return ret;
  }
  function discussion_update_your_comment_empty_class() {
    var isEmpty = quill.isEmpty();
    $('#discussion .comment-input').toggleClass('user-input-empty', isEmpty);
    $('#discussion .comment-input').toggleClass('user-input-not-empty', !isEmpty);
  }
  quill.on('text-change', function(delta, oldDelta, source) {
    discussion_update_your_comment_empty_class();
  });
  discussion_update_your_comment_empty_class();

  // fill in the context block on the right side
  $('#discussion .fillin-project_name').text(discussion_info.project.title);
  if (discussion.guests.length > 0 || 1) {
    // show guest count & names
    var text = " and " + discussion.guests.length + " guest";
    if (discussion.guests.length != 1) text += "s";
    if (discussion.guests.length > 1) {
      text += " (";
      for (var i = 0; i < discussion.guests.length; i++) {
        text += discussion.guests[i].name;
        if (i < discussion.guests.length-1)
          text += ", ";
      }
      text += ")";
    }
    $('#discussion .fillin-guests').text(text);
  }

  // POLLING FOR NEW COMMENTS

  // for polling, what did we last see
  discussion_info.max_comment_id = 0;
  discussion_info.max_event_time = 0;

  // render events
  $('#discussion .comment-thread').html('');
  render_events(discussion, true);

  // Autocomplete. The discussion object has a mapping from trigger
  // characters to autocomplete possibilities:
  //
  // {
  //   "@": [{
  //             "tag": "thing the autocomplete inserts",
  //             "display": "text displayed in the autocomplete popup",
  //         }, ... ]
  // }
  function make_autocomplete_strategy(trigger_character) {
    var autocomplete = discussion.autocomplete[trigger_character];

    RegExp.escape = function(s) {
      // http://stackoverflow.com/a/18151038
      return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
      replace(/\x08/g, '\\x08');
    };
    return {
      match: new RegExp("(^|\\s)" + RegExp.escape(trigger_character) + "(\\w*)$"),
      search: function (term, callback, match) {
        // Perform a search.
        var matches = [];
        term = match[2].toLowerCase().replace(/ /, "");
        for (var i = 0; i < autocomplete.length; i++) {
          var item = autocomplete[i];
          var search_key = (item.tag + item.display).toLowerCase().replace(/ /, "");
          if (search_key.indexOf(term) >= 0) {
            matches.push(item);
          }
        }
        callback(matches)
      },
      template: function(value) {
        if (!value.display)
          return value.tag;
        var node = $("<span><span class='display'/> <span class='tag' style='font-style: italic; padding-left: 1.5em;'/></span>");
        node.find(".display").text(value.display);
        node.find(".tag").text(value.tag);
        return node.html();
      },
      replace: function(value, event) { return "$1" + (trigger_character + value.tag).replace(/\$/g, "$$$$") + " "; } // must escape any dollar signs in the replacement text, and since we're using replace to do it we need to escape the literal $ twice!
    }
  };
  /* broken  $('#discussion-your-comment').textcomplete(
    Object.keys(discussion.autocomplete).map(make_autocomplete_strategy)
  , {
    // options
  });*/

  // start polling the server for new events
  discussion_poll();
}

function render_events(discussion, initial) {
  discussion.events.forEach(function(item) {
    if (item.type == "event")
        render_event(item, initial)
    else if (item.type == "comment")
        render_comment(item);
  });
}

function discussion_poll() {
  setTimeout(function() {
      discussion_poll_now(function(){
        discussion_poll(); // poll again
      })
    },

    // poll interval (10s)
    10000);
}

function discussion_poll_now(cb) {
  $.ajax({
      url: "{% url 'discussion_poll_for_events' %}",
      method: "POST",
      data: {
          id: discussion_info.id,
          comment_since: discussion_info.max_comment_id,
          event_since: discussion_info.max_event_time
      },
      success: function(res) {
        render_events(res);
        show_notification(res);
        if (cb) cb()
      }
  });
}

function show_notification(discussion) {
  function truncate(string) {
    if (string.length > 60)
      string = string.substring(0, 57) + "...";
    return string;
  }

  var notification = "";
  discussion.events.forEach(function(item) {
    if (!item.notification_text) return;
    if (item.user && item.user.id == {{request.user.id}}) return; // no notifications for actions the user took themself
    notification += truncate(item.notification_text) + "\n\n";
  })

  // if there's anything to show, show it
  if (notification != "")
    Push.create(discussion.discussion.title, {
      body: notification,
      /*icon: {
          x16: 'images/icon-x16.png',
          x32: 'images/icon-x32.png'
      },*/
      timeout: 5000
  });
}

function render_comment(item) {
  // Update existing DOM node?
  var n = $('#discussion .comment[data-id=ID], #discussion .reply[data-id=ID]'.replace(/ID/g, item.id));
  var isnew = false;
  if (n.length == 0) {
    // Create and fill in a DOM node.
    n = (!item.replies_to ? $('#comment-template') : $('#reply-template')).find('> div').clone();
    isnew = true;
  }

  // If the reaction is empty, i.e. if the emojis were edited-away, then hide the
  // DOM node. Continue processing because we still have to update max_comment_id
  // and update the emoji state, which is read back to pre-populate this user's
  // emoji reactions.
  n.toggle(!item.replies_to || (item.emojis != null && item.emojis.length > 0));

  // Fill in.
  n.attr('data-id', item.id);
  n.attr('data-sort-order', item.date_posix);
  if (item.user && item.user.picture)
    n.find('.comment-avatar').attr('src', item.user.picture.url).show();
  else
    n.find('.comment-avatar').hide();
  n.find('.comment-author').text(item.user.display_name || item.user.name);
  n.find('.comment-date').text(item.date_relative);
  n.find('.comment-date').attr('title', new Date(item.date_posix * 1000));
  n.find('.comment-author-role').text(item.user_role ? ("(" + item.user_role + ")") : "");
  n.find('.comment-text').html(item.text_rendered);
    n.find('.comment-text').find("img").addClass("img-responsive");
  n.attr('data-text', item.text);
  if (item.can_edit)
    n.addClass('has-edit-priv');
  if (item.can_delete)
    n.addClass('has-delete-priv');
  if (item.user.id == {{request.user.id}})
    n.addClass('author-is-self');
  n.find('.comment-emojis').html('');
  if (!item.emojis) item.emojis = []; // if null, turn into empty array
  n.attr('data-emojis', item.emojis.join(','));
  item.emojis.forEach(function(item) {
    n.find('.comment-emojis').append(emojione.toImage(":" + item + ":"))
  })

  // The rest is only if we're seeing a new comment.
  if (!isnew)
    return;

  // Update state - if any comments are present, change label.
  $('#discussion-your-comment-label').text("Add your comment:")
  discussion_has_any_comment = true;
  if (item.user.id != {{request.user.id}})
    discussion_has_any_comment_from_someone_else = true;
  var show_youre_alone = discussion_has_any_comment && !discussion_has_any_comment_from_someone_else;
  $('#discussion-you-are-alone').toggle(show_youre_alone && discussion_info.can_invite);
  $('#discussion #invite-guest').toggle(!show_youre_alone && discussion_info.can_invite);

  // Event handlers.
  n.find('textarea').keydown(textarea_ctrlenter_handler);

  // Add to the DOM.
  if (!item.replies_to) {
    var c = $('#discussion .comment-thread');
    c.append(n);
  } else {
    var parent = $('#discussion .comment[data-id=' + item.replies_to + ']');
    parent.find('.replies').append(n);
  }

  // Remember the last comment we've seen, for polling.
  if (item.id > discussion_info.max_comment_id)
    discussion_info.max_comment_id = item.id;

  // Scroll here if the window location fragment targets this.
  if (window.location.hash == "#discussion-comment-" + item.id)
    smooth_scroll_to(n);

  // Update containing document fields.
  discussion_comment_count += 1;
  $('#page-comment-count').text(discussion_comment_count + " comments");
}

function render_event(item, initial) {
  var n = $('#event-template > div').clone();
  n.attr('data-sort-order', item.date_posix);

  n.find('.event-text').html(item.html);
  n.find('.event-date').text(item.date_relative);
  n.find('.event-date').attr('title', new Date(item.date_posix * 1000));
  if (item.user && !item.user_is_in_text)
    n.find('.event-who').text("by " + item.user.name);
  if (item.user && item.user.picture)
    n.find('img.event-avatar').attr('src', item.user.picture.url).show();

  var c = $('#discussion .comment-thread')
  c.append(n);

  // Remember the last event we've seen, for polling.
  if (item.date_posix > discussion_info.max_event_time)
    discussion_info.max_event_time = item.date_posix;

  // For integration with outer template-
  if (!initial && window.on_discussion_event)
    window.on_discussion_event(item);
}

function start_update_draft_poller() {
  // Record the last time of a keypress in the comment box.
  var last_keypress_time = Date.now();
  quill.on('text-change', function(delta, oldDelta, source) {
    if (source == "user")
      last_keypress_time = Date.now();
  });

  // Check at intervals.
  setInterval(function() {
    if (is_submitting)
      return;
    if (Date.now() - last_keypress_time < 1000)
      return;
    update_draft();
  }, 500);
}

var draft_state = null;
var is_submitting = false;
function update_draft(force, callback) {
  var current_text = quill_delta_to_markdown(quill.getContents());
  if ((draft_state && current_text == draft_state.text)
      || (!force && !/\S/.test(current_text) && draft_state == null)) {
    if (callback)
      callback();
    return;
  }

  is_submitting = true;
  ajax_with_indicator({
    url: "{% url 'discussion-comment-draft' %}",
    method: "POST",
    data: {
      discussion: discussion_info.id,
      draft: draft_state ? draft_state.id : null,
      text: current_text
    },
    controls: $('#discussion .comment-input form').find('button'),
    success: function(c) {
      // Update state.
      draft_state = c;

      // Track the text we submitted, in case there is server-side
      // sanitization. We need to know what we submitted so we
      // can know if the textarea has been changed.
      draft_state.text = current_text;

      // Show status in UI.
      if (!callback) {
        $('#discussion-your-comment-saved')
          .text("Draft saved.")
          .fadeIn('fast');
        setTimeout(function() {
          $('#discussion-your-comment-saved').fadeOut()
        }, 1000);
      }
      
      // execute callback
      if (callback)
        callback();
    },
    complete: function() {
      is_submitting = false;
    }
  });  
}

function submit_comment(callback) {
  if (quill.isEmpty()) {
    // The comment is only whitespace. Don't save.
    // Execute callbazck immediately.
    if (callback)
      callback();
    return;
  }

  // First update the draft, then publish the draft.
  update_draft(true, function() {
    is_submitting = true;
    ajax_with_indicator({
      url: "{% url 'discussion-comment-submit' %}",
      method: "POST",
      data: {
        discussion: discussion_info.id,
        draft: draft_state.id
      },
      controls: $('#discussion .comment-input form').find('textarea, input, button'),
      success: function(c) {
        // keep the window scrolled such that the input box stays
        // in the same place -- i.e., the new comment pushes things
        // up.
        var y = $('#discussion .comment-input').offset().top - $(window).scrollTop();

        // clear text input, reset draft state
        quill.setText("");
        draft_state = null;

        // render the comment in the thread
        render_comment(c)

        // adjust scroll position
        $(window).scrollTop($('#discussion .comment-input').offset().top - y);

        // execute callback
        if (callback)
          callback();
      },
      complete: function() {
        is_submitting = false;
      }
    })
  });
}

function get_comment_from_command_elem(command_elem) {
  var c = $(command_elem).parents(".comment");
  if (c.length == 0) throw "something went wrong";
  return c;
}

function begin_comment_edit(command_elem) {
  var c = get_comment_from_command_elem(command_elem);
  c.find('.comment-edit textarea').css({ minHeight: c.find('.comment-text').height()+30 });
  c.find('.comment-edit textarea').val(c.attr('data-text'));
  c.find('.comment-text').hide();
  c.find('.comment-edit').show();
  return false;
}

function close_comment_edit(command_elem) {
  var c = get_comment_from_command_elem(command_elem);
  c.find('.comment-text').show();
  c.find('.comment-edit').hide();
  return false;
}

function do_comment_save(command_elem) {
  var c = get_comment_from_command_elem(command_elem);
  ajax_with_indicator({
    url: "{% url 'discussion-comment-edit' %}",
    method: "POST",
    data: {
      id: c.attr('data-id'),
      text: c.find('.comment-edit textarea').val()
    },
    controls: c.find('textarea, input, button'),
    success: function(res) {
      // update UI
      render_comment(res);
      close_comment_edit(command_elem);
    }
  })
}

function do_delete_comment(command_elem) {
  var c = get_comment_from_command_elem(command_elem);
  show_modal_confirm(
    "Delete Comment",
    "Are you sure you want to delete that comment?",
    "Delete",
    function() {
      ajax_with_indicator({
        url: "{% url 'discussion-comment-delete' %}",
        method: "POST",
        data: {
          id: c.attr('data-id')
        },
        success: function(res) {
          c.slideUp();
        }
      })
    });
  return false;
}

var current_emoji_reaction = null;

function begin_emoji_reaction(event, command_elem) {
  // We have a click handler on the document to close the
  // reaction dialog. But clicking on the button to open
  // the dialog should not propagate and trigger that.
  event.stopPropagation();

  // Save any emoji reaction currently being edited.
  if (current_emoji_reaction) {
    save_emoji_reaction();
    return false;
  }

  // Initialize and show.
  var c = get_comment_from_command_elem(command_elem);
  current_emoji_reaction = c;
  var et = c.find('.comment-meta .react-with-emoji');
  var es = $('#emoji-selector');

  // reset state to previously reacted emojis
  es.find('.emoji').removeClass('active');
  var emojis = c.find('.replies .author-is-self').attr('data-emojis');
  if (emojis) {
    emojis.split(',').forEach(function(shortname) {
      es.find('.emoji').each(function() {
        if (this.getAttribute('data-emoji-name') == shortname)
          $(this).addClass('active');
      });
    });
  }

  es.css({
    display: 'block',
    position: 'absolute',
    width: '20em',
    left: et.offset().left + et.width() + 5,
    top: et.offset().top - 30
  })
  return false;
}

function save_emoji_reaction() {
  var es = $('#emoji-selector').hide();
  if (!current_emoji_reaction)
    return;

  // what emojis are selected
  var emojis = [];
  es.find('.emoji.active').each(function() {
    emojis.push($(this).attr('data-emoji-name'));
  })

  // update db
  ajax_with_indicator({
    url: "{% url 'discussion-comment-react' %}",
    method: "POST",
    data: {
      id: current_emoji_reaction.attr('data-id'),
      emojis: emojis.join(",")
    },
    success: function(res) {
      // updates UI
      render_comment(res);
    }
  })
  current_emoji_reaction = null;
}

function attach_files(files) {
  // Update the draft to ensure there is a draft to attach the
  // attachments to.
  update_draft(true, function() {
    // Create an AJAX request to upload all of the files at once.
    var data = new FormData();
    data.append("discussion", discussion_info.id);
    data.append("draft", draft_state.id);
    for (var i = 0; i < files.length; i++)
      data.append("file" + i, files[i])
    
    // Submit the ajax request.
    ajax_with_indicator({
      url: "{% url 'discussion-comment-create-attachments' %}",
      data: data,
      controls: $('#discussion .comment-input form').find('textarea, input, button'),
      success: function(res) {
        // We get back a mapping indicating what was uploaded.
        Object.keys(res).forEach(function(key) {
          var attachment = res[key];
          var ins;
          if (attachment.is_image) {
            quill.insertEmbed(
              quill.getSelection(true).index,
              'image',
              attachment.url);
          } else {
            // Insert a link to the attachment.
            quill.insertText(
              quill.getSelection(true).index, 
              attachment.original_fn.replace(/[\\[\]]/g, ""),
              {
                'link': attachment.url
              });
          }
        });
      }
    });
  });
}

function quill_delta_to_markdown(delta) {
  // Render the Quill widget's content, which we can only obtain
  // in its "Delta" format, into CommonMark.

  if (quill.isEmpty())
    return "";

  // Form the Markdown document as an array of block, where each
  // block is an array of inlines (strings).
  var md = [[ { raw: "", md: "" } ]];
  delta.ops.forEach(function(op) {
    if (typeof op.insert === "string") {
      // Text insertion.
      op.insert.split(/(\n)/).forEach(function(text) {
        var block = md[md.length-1];

        if (text != "\n") {
          var raw_text = text;

          // Escape punctuation.
          // Backslash escapes do not work in code blocks or code spans.
          // We'll handle code blocks later.
          if (!op.attributes || !op.attributes.code) {
            text = text.replace(
              /[!"#$%&'()*+,\-./:;<=>?@\[\\\]^_`{|}~]/g,
              function(p) { return "\\" + p },
              text);
          }

          // Add text as an inline.
          if (op.attributes) {
            var inlink = false;

            if (op.attributes.link) {
              // In order to join consecutive ops with the same link target,
              // we'll insert this text in parts. If we see that we're in the
              // same link, pop the end of the link so we can continue it.
              // Do this ahead of bold/italics so that we can see if we need
              // to alernate the symbol.
              if (block[block.length-1].md == "](" + op.attributes.link + ")") {
                block.pop(); // pop and re-add after the text.
                inlink = true;
              }
            }

            // To avoid clashing emphasis markers, if the last inline
            // ended with * or _, use the other for this inline.
            var em = "*";
            if (/\*$/.test(block[block.length-1].md))
              em = "_";

            if (op.attributes.italic)
              text = em + text + em;
            if (op.attributes.bold)
              text = em + em + text + em + em;
            
            if (op.attributes.code)
              text = "`" + text + "`";

            if (op.attributes.link) {
              if (!inlink)
                block.push({ raw: "", md: "[" });
              block.push({ raw: raw_text, md: text });
              block.push({ raw: "", md: "](" + op.attributes.link + ")" });
              return;
            }
          }

          block.push({ raw: raw_text, md: text });

        } else {
          // This is a newline. Apply block-level attributes to the
          // current block, then start a new block.
          if (op.attributes) {
            if (op.attributes.header) {
              var h = "";
              for (var i = 0; i < op.attributes.header; i++)
                h += "#";
              block.unshift({ raw: "", md: h + " "});
            } else if (op.attributes.list == "ordered") {
              block.unshift({ raw: "", md: "1. "});
            } else if (op.attributes.list == "bullet") {
              block.unshift({ raw: "", md: "* "});
            } else if (op.attributes.blockquote) {
              block.unshift({ raw: "", md: "> "});
            } else if ("code-block" in op.attributes) {
              // Use only raw text in code blocks - no markdown formatting.
              block.forEach(function(inline) { inline.md = inline.raw; });
              block.unshift({ raw: "", md: "    "});
            }
          }
          md.push([{ raw: "", md: "" }]);
        }
      });

    } else if (op.insert.image) {
      // This holds a URL or data URI. We'll convert the data URI
      // to an attachment + a safe URI on the server side, since data URIs
      // are not safe in CommonMark.
      var block = md[md.length-1];
      block.push({ raw: "", md: "![](" + op.insert.image + ")"})
    }
  });
  return md.map(function(block) { return block.map(function(inline) { return inline.md }).join(""); }).join("\n\n");
}

</script>